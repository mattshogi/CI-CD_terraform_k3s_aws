name: CI/CD Pipeline

permissions:
  contents: read
  packages: write
  security-events: write

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      destroy_staging:
        description: "Run terraform destroy for staging after validation"
        required: false
        default: "false"
      destroy_production:
        description: "Run terraform destroy for production after validation"
        required: false
        default: "false"
      run_apply:
        description: "Run terraform apply + validation (ephemeral)"
        required: false
        default: "false"
      apply_environment:
        description: "Environment to apply (staging|production)"
        required: false
        default: "staging"
      destroy_after_apply:
        description: "Destroy after validation (only if run_apply=true)"
        required: false
        default: "true"
      instance_type_override:
        description: "Override instance type for apply job"
        required: false
        default: "t3.small"
      enable_monitoring:
        description: "Enable monitoring stack (kube-prometheus-stack)"
        required: false
        default: "true"

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: mattshogi/ci-cd_terraform_k3s_aws/hello-world

jobs:
  # Test and build the Go application
  test-app:
    name: Test Go Application
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        working-directory: ./app
        run: go mod download

      - name: Run tests
        working-directory: ./app
        run: go test -v ./...

      - name: Build application
        working-directory: ./app
        run: go build -o hello-world .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: hello-world-binary
          path: app/hello-world

  # Build and test Docker image
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test-app
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Show resolved image tags
        run: |
          echo "Image name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "Tags:"
          echo '${{ steps.meta.outputs.tags }}' | tr ' ' '\n'

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app
          # Use single-arch build in CI for speed; multi-arch handled in release workflow
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Validate Terraform configurations
  terraform-validate:
    name: Validate Terraform
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        terraform-dir: ['infra', 'infra/server'] # 'infra/agents' temporarily excluded (experimental)
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Terraform Init (no backend)
        working-directory: ${{ matrix.terraform-dir }}
        run: terraform init -backend=false -input=false

      - name: Terraform Format Check
        working-directory: ${{ matrix.terraform-dir }}
        run: terraform fmt -check

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: v0.50.0

      - name: TFLint Init
        working-directory: ${{ matrix.terraform-dir }}
        run: tflint --init

      - name: TFLint Run
        working-directory: ${{ matrix.terraform-dir }}
        run: tflint -f compact | tee tflint.out
        continue-on-error: true

      - name: Upload TFLint Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tflint-${{ matrix.terraform-dir == 'infra/server' && 'infra-server' || 'infra' }}-${{ github.run_attempt }}
          path: ${{ matrix.terraform-dir }}/tflint.out
          if-no-files-found: ignore
          overwrite: true

      - name: Terraform Validate
        working-directory: ${{ matrix.terraform-dir }}
        id: tf-validate
        run: |
          set -euo pipefail
          echo "Running terraform validate (human readable)"
          terraform validate -no-color | tee terraform-validate.out || echo "VALIDATE_FAILED=1" >> $GITHUB_OUTPUT
          echo "Capturing JSON validation output (non-fatal)"
          terraform validate -json > terraform-validate.json || true

      - name: Debug (server module context)
        if: matrix.terraform-dir == 'infra/server'
        working-directory: ${{ matrix.terraform-dir }}
        run: |
          echo '--- DEBUG DIR STRUCTURE ---'
          pwd
            
          echo 'Listing cluster directory referenced by templatefile'
          ls -al ${GITHUB_WORKSPACE}/cluster || true
          echo '--- Show main.tf snippet (lines 1-40) ---'
          sed -n '1,120p' main.tf
          echo '--- Run terraform validate -json ---'
          terraform validate -json || true

      - name: Upload Terraform Validate Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-validate-${{ matrix.terraform-dir == 'infra/server' && 'infra-server' || 'infra' }}-${{ github.run_attempt }}
          path: |
            ${{ matrix.terraform-dir }}/terraform-validate.out
            ${{ matrix.terraform-dir }}/terraform-validate.json
          if-no-files-found: ignore
          overwrite: true

      - name: Fail on validation errors
        if: steps.tf-validate.outputs.VALIDATE_FAILED == '1'
        run: |
          echo "Terraform validation failed in directory ${{ matrix.terraform-dir }}" >&2
          exit 1

  # Validate Helm charts
  helm-validate:
    name: Validate Helm Charts
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0

      - name: Helm Lint
        run: helm lint charts/hello-world/

      - name: Helm Template
        run: |
          helm template hello-world charts/hello-world/ \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=latest

  # Security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-docker
    permissions:
      contents: read
      packages: read
      security-events: write
    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-docker.outputs.image-digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL'
          exit-code: '0' # collect results without failing; we gate manually next
          ignore-unfixed: true
          vuln-type: 'os,library'

      - name: Run Trivy JSON (for gating)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-docker.outputs.image-digest }}
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL'
          ignore-unfixed: true
          vuln-type: 'os,library'
          exit-code: '0'

      - name: Evaluate vulnerability threshold
        run: |
          CRIT_COUNT=$(jq '.Results[].Vulnerabilities // [] | map(select(.Severity=="CRITICAL")) | length' trivy-results.json 2>/dev/null | paste -sd+ - | bc || echo 0)
          echo "Critical vulnerability count: $CRIT_COUNT"
          THRESHOLD=${VULN_CRITICAL_THRESHOLD:-0}
          if [ "$CRIT_COUNT" -gt "$THRESHOLD" ]; then
            echo "âŒ Exceeds CRITICAL vulnerability threshold ($THRESHOLD). Failing job." >&2
            exit 1
          else
            echo "âœ… Within CRITICAL vulnerability threshold ($THRESHOLD)."
          fi
        env:
          VULN_CRITICAL_THRESHOLD: 0

      - name: Show Trivy summary
        if: always()
        run: |
          if [ -f trivy-results.sarif ]; then
            echo "First 20 lines of SARIF:"
            head -n 20 trivy-results.sarif || true
          fi

      - name: Upload raw Trivy JSON
        if: always()
        uses: actions/upload-artifact@v4
        with:
            name: trivy-json-${{ github.run_attempt }}
            path: trivy-results.json
            if-no-files-found: ignore

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Integration tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test-app, build-docker]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Set up Helm (for lint in script if needed)
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0

      - name: Show tool versions
        run: |
          terraform -version
          helm version || true
          docker version --format '{{.Server.Version}}' || true

      - name: Run integration tests
        run: |
          # Make the script executable
          chmod +x scripts/test-integration.sh
          
          # Run integration tests
          ./scripts/test-integration.sh

  # Deploy to staging (on main branch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [terraform-validate, helm-validate, security-scan, integration-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Terraform Format Check
        working-directory: infra
        run: terraform fmt -check

      - name: Terraform Plan (Dry Run)
        working-directory: infra
        run: terraform init -backend=false -input=false

      - name: Terraform Plan (Dry Run - With AWS Credentials)
        working-directory: infra
        run: |
          export AWS_DEFAULT_REGION=us-east-1
          if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            echo "Running staging plan with provided AWS credentials"
            terraform plan \
              -var="ssh_key_name=${AWS_SSH_KEY_NAME:-}" \
              -var="instance_type=t3.small" \
              -var="enable_monitoring=true" \
              -var="environment=staging"
          else
            echo "Skipping staging plan (AWS credentials not set)."
          fi

  # Skip step removed; handled inline above.

      - name: Staging deployment completed
        run: |
          echo "âœ… Staging deployment validation completed"
          echo "ðŸš€ Ready for production deployment"

  # Deploy to production (manual trigger or tag)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [terraform-validate, helm-validate, security-scan, integration-tests]
    if: github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Production deployment validation
        working-directory: infra
        run: terraform init -backend=false -input=false

      - name: Terraform Plan (Dry Run - With AWS Credentials)
        working-directory: infra
        run: |
          export AWS_DEFAULT_REGION=us-east-1
          if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            echo "Running production plan with provided AWS credentials"
            terraform plan \
              -var="ssh_key_name=${AWS_SSH_KEY_NAME:-}" \
              -var="instance_type=t3.small" \
              -var="enable_monitoring=true" \
              -var="environment=production"
          else
            echo "Skipping production plan (AWS credentials not set)."
          fi

  # Skip step removed; handled inline above.

      - name: Production deployment completed
        run: |
          echo "âœ… Production deployment validation completed"
          echo "ðŸŽ‰ Production deployment ready!"

  destroy-staging:
    name: Destroy Staging (Optional)
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'workflow_dispatch' && inputs.destroy_staging == 'true'
    steps:
      - uses: actions/checkout@v4
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5
      - name: Terraform Destroy (Staging)
        working-directory: infra
        env:
          TF_VAR_environment: staging
        run: |
          terraform init -backend=false
          terraform destroy -auto-approve \
            -var="ssh_key_name=dummy-key" \
            -var="instance_type=t3.micro" \
            -var="environment=staging"

  destroy-production:
    name: Destroy Production (Optional)
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: github.event_name == 'workflow_dispatch' && inputs.destroy_production == 'true'
    steps:
      - uses: actions/checkout@v4
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5
      - name: Terraform Destroy (Production)
        working-directory: infra
        env:
          TF_VAR_environment: production
        run: |
          terraform init -backend=false
          terraform destroy -auto-approve \
            -var="ssh_key_name=production-key" \
            -var="instance_type=t3.small" \
            -var="environment=production"

  infra-apply-validate:
    name: Apply & Validate (Ephemeral)
    runs-on: ubuntu-latest
    needs: [terraform-validate, helm-validate, security-scan, integration-tests]
    if: github.event_name == 'workflow_dispatch' && inputs.run_apply == 'true'
    outputs:
      server_public_ip: ${{ steps.capture-ip.outputs.server_public_ip }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Configure AWS credentials (optional)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Terraform Init
        working-directory: infra
        run: terraform init -backend=false -input=false

      - name: Terraform Apply
        id: tf-apply
        working-directory: infra
        env:
          TF_IN_AUTOMATION: true
        run: |
          set -euo pipefail
          if [ -z "${AWS_ACCESS_KEY_ID:-}" ] || [ -z "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            echo "AWS credentials not provided; skipping apply." >&2
            echo "apply_skipped=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          terraform apply -auto-approve \
            -var="ssh_key_name=${AWS_SSH_KEY_NAME:-}" \
            -var="instance_type=${{ inputs.instance_type_override }}" \
            -var="enable_monitoring=${{ inputs.enable_monitoring }}" \
            -var="environment=${{ inputs.apply_environment }}"
          terraform output -json > tf-outputs.json

      - name: Capture public IP
        id: capture-ip
        if: steps.tf-apply.outcome == 'success' && steps.tf-apply.outputs.apply_skipped != 'true'
        working-directory: infra
        run: |
          SERVER_IP=$(jq -r '.server_public_ip.value' tf-outputs.json 2>/dev/null || echo '')
          echo "server_public_ip=$SERVER_IP" >> $GITHUB_OUTPUT
          echo "Server IP: $SERVER_IP"

      - name: Validate Endpoints
        if: steps.capture-ip.outputs.server_public_ip != ''
        working-directory: infra
        env:
          SERVER_IP: ${{ steps.capture-ip.outputs.server_public_ip }}
          HELLO_NODE_PORT: 30080
          GRAFANA_NODE_PORT: 30030
          PROM_NODE_PORT: 30900
        run: |
          set -euo pipefail
          echo "Starting endpoint validation against $SERVER_IP"
          retries=40
          sleep_between=15
          endpoints="root:http://$SERVER_IP/ hello:http://$SERVER_IP:$HELLO_NODE_PORT/ grafana:http://$SERVER_IP:$GRAFANA_NODE_PORT/ prometheus:http://$SERVER_IP:$PROM_NODE_PORT/"
          mkdir -p validation
          summary=validation/summary.md
          echo "# Endpoint Validation Summary" > $summary
          echo "Server IP: $SERVER_IP" >> $summary
          pass_count=0
          total=0
          for item in $endpoints; do
            total=$((total+1))
            name=${item%%:*}
            url=${item#*:}
            echo "\n## $name ($url)" >> $summary
            ok=false
            for ((i=1;i<=retries;i++)); do
              code=$(curl -m 5 -s -o /dev/null -w '%{http_code}' "$url" || echo 000)
              echo "[$name] attempt $i/$retries -> $code"
              if [ "$code" = "200" ]; then
                echo "Success ($code) on attempt $i" >> $summary
                ok=true; pass_count=$((pass_count+1)); break
              fi
              sleep $sleep_between
            done
            if [ "$ok" = false ]; then
              echo "Failed after $retries attempts" >> $summary
            fi
          done
          echo "\n---\nPassed $pass_count of $total endpoints" >> $summary
          if [ $pass_count -lt 2 ]; then
            echo "Insufficient endpoints healthy ($pass_count/$total)" >> $summary
            # don't fail immediately; capture artifact first
          fi

      - name: Upload Validation Summary
        if: steps.capture-ip.outputs.server_public_ip != ''
        uses: actions/upload-artifact@v4
        with:
          name: infra-apply-validation-${{ github.run_attempt }}
          path: infra/validation/summary.md
          if-no-files-found: warn

      - name: Terraform Destroy (auto)
        if: inputs.destroy_after_apply == 'true' && steps.capture-ip.outputs.server_public_ip != ''
        working-directory: infra
        run: |
          if [ -z "${AWS_ACCESS_KEY_ID:-}" ] || [ -z "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            echo "AWS credentials not provided; skipping destroy." >&2
            exit 0
          fi
          terraform destroy -auto-approve \
            -var="ssh_key_name=${AWS_SSH_KEY_NAME:-}" \
            -var="instance_type=${{ inputs.instance_type_override }}" \
            -var="enable_monitoring=${{ inputs.enable_monitoring }}" \
            -var="environment=${{ inputs.apply_environment }}"

