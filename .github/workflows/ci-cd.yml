name: CI/CD Pipeline

permissions:
  contents: read
  packages: write
  security-events: write

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      destroy_staging:
        description: "Run terraform destroy for staging after validation"
        required: false
        default: "false"
      destroy_production:
        description: "Run terraform destroy for production after validation"
        required: false
        default: "false"

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: mattshogi/ci-cd_terraform_k3s_aws/hello-world

jobs:
  # Test and build the Go application
  test-app:
    name: Test Go Application
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        working-directory: ./app
        run: go mod download

      - name: Run tests
        working-directory: ./app
        run: go test -v ./...

      - name: Build application
        working-directory: ./app
        run: go build -o hello-world .

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: hello-world-binary
          path: app/hello-world

  # Build and test Docker image
  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test-app
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Show resolved image tags
        run: |
          echo "Image name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo "Tags:"
          echo '${{ steps.meta.outputs.tags }}' | tr ' ' '\n'

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./app
          # Use single-arch build in CI for speed; multi-arch handled in release workflow
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Validate Terraform configurations
  terraform-validate:
    name: Validate Terraform
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        terraform-dir: ['infra', 'infra/server'] # 'infra/agents' temporarily excluded (experimental)
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Terraform Init (no backend)
        working-directory: ${{ matrix.terraform-dir }}
        run: terraform init -backend=false -input=false

      - name: Terraform Format Check
        working-directory: ${{ matrix.terraform-dir }}
        run: terraform fmt -check

      - name: Setup TFLint
        uses: terraform-linters/setup-tflint@v4
        with:
          tflint_version: v0.50.0

      - name: TFLint Init
        working-directory: ${{ matrix.terraform-dir }}
        run: tflint --init

      - name: TFLint Run
        working-directory: ${{ matrix.terraform-dir }}
        run: tflint -f compact | tee tflint.out
        continue-on-error: true

      - name: Upload TFLint Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: tflint-${{ matrix.terraform-dir == 'infra/server' && 'infra-server' || 'infra' }}-${{ github.run_attempt }}
          path: ${{ matrix.terraform-dir }}/tflint.out
          if-no-files-found: ignore
          overwrite: true

      - name: Terraform Validate
        working-directory: ${{ matrix.terraform-dir }}
        run: terraform validate -no-color | tee terraform-validate.out

      - name: Debug (server module context)
        if: matrix.terraform-dir == 'infra/server'
        working-directory: ${{ matrix.terraform-dir }}
        run: |
          echo '--- DEBUG DIR STRUCTURE ---'
          pwd
            
          echo 'Listing cluster directory referenced by templatefile'
          ls -al ${GITHUB_WORKSPACE}/cluster || true
          echo '--- Show main.tf snippet (lines 1-40) ---'
          sed -n '1,120p' main.tf
          echo '--- Run terraform validate -json ---'
          terraform validate -json || true

      - name: Upload Terraform Validate Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-validate-${{ matrix.terraform-dir == 'infra/server' && 'infra-server' || 'infra' }}-${{ github.run_attempt }}
          path: ${{ matrix.terraform-dir }}/terraform-validate.out
          if-no-files-found: ignore
          overwrite: true

  # Validate Helm charts
  helm-validate:
    name: Validate Helm Charts
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0

      - name: Helm Lint
        run: helm lint charts/hello-world/

      - name: Helm Template
        run: |
          helm template hello-world charts/hello-world/ \
            --set image.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            --set image.tag=latest

  # Security scanning
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-docker
    permissions:
      contents: read
      packages: read
      security-events: write
    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-docker.outputs.image-digest }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL'
          exit-code: '0' # collect results without failing; we gate manually next
          ignore-unfixed: true
          vuln-type: 'os,library'

      - name: Run Trivy JSON (for gating)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-docker.outputs.image-digest }}
          format: 'json'
          output: 'trivy-results.json'
          severity: 'CRITICAL'
          ignore-unfixed: true
          vuln-type: 'os,library'
          exit-code: '0'

      - name: Evaluate vulnerability threshold
        run: |
          CRIT_COUNT=$(jq '.Results[].Vulnerabilities // [] | map(select(.Severity=="CRITICAL")) | length' trivy-results.json 2>/dev/null | paste -sd+ - | bc || echo 0)
          echo "Critical vulnerability count: $CRIT_COUNT"
          THRESHOLD=${VULN_CRITICAL_THRESHOLD:-0}
          if [ "$CRIT_COUNT" -gt "$THRESHOLD" ]; then
            echo "âŒ Exceeds CRITICAL vulnerability threshold ($THRESHOLD). Failing job." >&2
            exit 1
          else
            echo "âœ… Within CRITICAL vulnerability threshold ($THRESHOLD)."
          fi
        env:
          VULN_CRITICAL_THRESHOLD: 0

      - name: Show Trivy summary
        if: always()
        run: |
          if [ -f trivy-results.sarif ]; then
            echo "First 20 lines of SARIF:"
            head -n 20 trivy-results.sarif || true
          fi

      - name: Upload raw Trivy JSON
        if: always()
        uses: actions/upload-artifact@v4
        with:
            name: trivy-json-${{ github.run_attempt }}
            path: trivy-results.json
            if-no-files-found: ignore

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Integration tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test-app, build-docker]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Set up Helm (for lint in script if needed)
        uses: azure/setup-helm@v3
        with:
          version: v3.12.0

      - name: Show tool versions
        run: |
          terraform -version
          helm version || true
          docker version --format '{{.Server.Version}}' || true

      - name: Run integration tests
        run: |
          # Make the script executable
          chmod +x scripts/test-integration.sh
          
          # Run integration tests
          ./scripts/test-integration.sh

  # Deploy to staging (on main branch)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [terraform-validate, helm-validate, security-scan, integration-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Terraform Format Check
        working-directory: infra
        run: terraform fmt -check

      - name: Terraform Plan (Dry Run)
        working-directory: infra
        run: terraform init -backend=false -input=false

      - name: Terraform Plan (Dry Run - With AWS Credentials)
        working-directory: infra
        run: |
          export AWS_DEFAULT_REGION=us-east-1
          if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            echo "Running staging plan with provided AWS credentials"
            terraform plan \
              -var="ssh_key_name=${AWS_SSH_KEY_NAME:-}" \
              -var="instance_type=t3.micro" \
              -var="environment=staging"
          else
            echo "Skipping staging plan (AWS credentials not set)."
          fi

  # Skip step removed; handled inline above.

      - name: Staging deployment completed
        run: |
          echo "âœ… Staging deployment validation completed"
          echo "ðŸš€ Ready for production deployment"

  # Deploy to production (manual trigger or tag)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [terraform-validate, helm-validate, security-scan, integration-tests]
    if: github.event_name == 'workflow_dispatch' || startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Production deployment validation
        working-directory: infra
        run: terraform init -backend=false -input=false

      - name: Terraform Plan (Dry Run - With AWS Credentials)
        working-directory: infra
        run: |
          export AWS_DEFAULT_REGION=us-east-1
          if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
            echo "Running production plan with provided AWS credentials"
            terraform plan \
              -var="ssh_key_name=${AWS_SSH_KEY_NAME:-}" \
              -var="instance_type=t3.small" \
              -var="environment=production"
          else
            echo "Skipping production plan (AWS credentials not set)."
          fi

  # Skip step removed; handled inline above.

      - name: Production deployment completed
        run: |
          echo "âœ… Production deployment validation completed"
          echo "ðŸŽ‰ Production deployment ready!"

  destroy-staging:
    name: Destroy Staging (Optional)
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'workflow_dispatch' && inputs.destroy_staging == 'true'
    steps:
      - uses: actions/checkout@v4
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5
      - name: Terraform Destroy (Staging)
        working-directory: infra
        env:
          TF_VAR_environment: staging
        run: |
          terraform init -backend=false
          terraform destroy -auto-approve \
            -var="ssh_key_name=dummy-key" \
            -var="instance_type=t3.micro" \
            -var="environment=staging"

  destroy-production:
    name: Destroy Production (Optional)
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: github.event_name == 'workflow_dispatch' && inputs.destroy_production == 'true'
    steps:
      - uses: actions/checkout@v4
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5
      - name: Terraform Destroy (Production)
        working-directory: infra
        env:
          TF_VAR_environment: production
        run: |
          terraform init -backend=false
          terraform destroy -auto-approve \
            -var="ssh_key_name=production-key" \
            -var="instance_type=t3.small" \
            -var="environment=production"
