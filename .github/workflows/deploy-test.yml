name: Ephemeral Deploy Test

on:
  workflow_dispatch:
    inputs:
      instance_type:
        description: EC2 instance type
        required: false
        default: t3.micro
      keep_resources:
        description: 'Keep resources after test (true/false)'
        required: false
        default: 'false'
      k3s_node_count:
        description: 'Number of agent nodes'
        required: false
        default: '0'
      environment:
        description: 'Environment tag (for resource naming)'
        required: false
        default: 'gha-test'
      readiness_attempts:
        description: 'Number of validation attempts (10s interval)'
        required: false
        default: '30'
      enable_monitoring:
        description: 'Install monitoring stack (true/false)'
        required: false
        default: 'false'
      install_docker:
        description: 'Install Docker engine (true/false)'
        required: false
        default: 'false'
      keep_on_failure:
        description: 'Do not destroy resources if apply or validation fails (for debugging)'
        required: false
        default: 'false'

concurrency:
  group: deploy-test
  cancel-in-progress: false

env:
  TF_IN_AUTOMATION: 1
  AWS_REGION: us-east-1
  TERRAFORM_CLI_ARGS: -no-color

jobs:
  deploy-validate-destroy:
    name: Provision → Validate → (Destroy)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect AWS credentials
        id: detect
        run: |
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then echo "aws=true" >> $GITHUB_OUTPUT; else echo "aws=false" >> $GITHUB_OUTPUT; fi

      - name: Fail fast if AWS credentials missing
        if: steps.detect.outputs.aws != 'true'
        run: |
          echo "ERROR: AWS credentials not provided." >&2; exit 1

      - name: Configure AWS credentials
        if: steps.detect.outputs.aws == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        run: aws sts get-caller-identity

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5

      - name: Terraform Init
        working-directory: infra
        run: terraform init -input=false

      - name: Terraform Plan
        id: plan
        working-directory: infra
        run: |
          terraform plan \
            -var="ssh_key_name=${{ secrets.AWS_SSH_KEY_NAME }}" \
            -var="instance_type=${{ github.event.inputs.instance_type }}" \
            -var="k3s_node_count=${{ github.event.inputs.k3s_node_count }}" \
            -var="environment=${{ github.event.inputs.environment || 'gha-test' }}" \
            -var="enable_monitoring=${{ github.event.inputs.enable_monitoring == 'true' }}" \
            -var="install_docker=${{ github.event.inputs.install_docker == 'true' }}" \
            -var="resource_name_suffix=${{ github.run_id }}" \
            -out=tfplan

      - name: Terraform Apply
        id: apply
        working-directory: infra
        run: |
          set -o pipefail
          terraform apply -auto-approve tfplan 2>&1 | tee ../terraform-apply.log
          ec=${PIPESTATUS[0]}
          echo "apply_exit_code=$ec" >> $GITHUB_OUTPUT
          if [ $ec -ne 0 ]; then echo "[WARN] Terraform apply failed (will evaluate retry logic)" >&2; fi

      - name: Transient retry (simple)
        id: apply_retry
        if: ${{ steps.apply.outputs.apply_exit_code != '0' }}
        working-directory: infra
        run: |
          echo "Attempting simple transient retry (throttling/IAM propagation)"
          if ! grep -qiE 'Throttling|RequestLimitExceeded|InvalidIAMInstanceProfile|NoSuchEntity|DependencyViolation|ServiceUnavailable|InternalError' ../terraform-apply.log 2>/dev/null; then
            echo "No transient patterns detected; skipping retry"; echo "apply_retry_exit_code=NA" >> $GITHUB_OUTPUT; exit 0
          fi
          sleep 25
          set -o pipefail
          terraform apply -auto-approve tfplan 2>&1 | tee -a ../terraform-apply.log
          ec=${PIPESTATUS[0]}
          echo "apply_retry_exit_code=$ec" >> $GITHUB_OUTPUT
          if [ $ec -ne 0 ]; then echo "Retry still failed" >&2; fi

      - name: Set final apply status
        if: always()
        id: apply_final
        run: |
          init='${{ steps.apply.outputs.apply_exit_code }}'
          retry='${{ steps.apply_retry.outputs.apply_retry_exit_code }}'
          final=$init
          if [ -n "$retry" ] && [ "$retry" != "NA" ]; then final=$retry; fi
          echo "final_apply_exit_code=$final" >> $GITHUB_OUTPUT
          echo "Final apply exit code: $final"

      - name: Show terraform apply log tail (on failure)
        if: ${{ steps.apply_final.outputs.final_apply_exit_code != '0' }}
        run: |
          echo "---- terraform-apply.log (last 120 lines) ----"
          tail -n 120 terraform-apply.log || true

      - name: Capture Terraform outputs
        if: ${{ steps.apply_final.outputs.final_apply_exit_code == '0' }}
        id: tf-out
        working-directory: infra
        run: |
          sudo apt-get update -y >/dev/null 2>&1 || true
          sudo apt-get install -y jq >/dev/null 2>&1 || true
          out_json=$(terraform output -json || exit 1)
          ip=$(echo "$out_json" | jq -r '.server_public_ip.value // empty')
          iid=$(echo "$out_json" | jq -r '.server_instance_id.value // empty')
          [ -z "$ip" ] && ip=UNKNOWN
          [ -z "$iid" ] && iid=UNKNOWN
          echo "server_ip=$ip" >> $GITHUB_OUTPUT
          echo "instance_id=$iid" >> $GITHUB_OUTPUT

      - name: Echo outputs
        if: ${{ steps.apply_final.outputs.final_apply_exit_code == '0' }}
        run: |
          echo "Server IP: ${{ steps.tf-out.outputs.server_ip }}"
          echo "Instance ID: ${{ steps.tf-out.outputs.instance_id }}"
          if ! echo "${{ steps.tf-out.outputs.instance_id }}" | grep -q '^i-'; then echo "[WARN] Instance ID pattern invalid"; fi

      - name: Warm-up (k3s install)
        if: ${{ steps.apply_final.outputs.final_apply_exit_code == '0' }}
        run: |
          echo "Warm-up 75s for k3s core components"
          sleep 75

      - name: Wait monitoring components (pods/services)
        if: ${{ github.event.inputs.enable_monitoring == 'true' && steps.apply_final.outputs.final_apply_exit_code == '0' }}
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          if [ -z "$iid" ] || [ "$iid" = "UNKNOWN" ] || ! echo "$iid" | grep -q '^i-'; then echo "Skip monitoring wait (invalid instance id)"; exit 0; fi
          echo "Waiting for monitoring pods (timeout 6m)"
          deadline=$((SECONDS+360))
          while [ $SECONDS -lt $deadline ]; do
            CID=$(aws ssm send-command --instance-ids "$iid" --document-name AWS-RunShellScript --parameters commands='k3s kubectl get pods -n monitoring --no-headers 2>/dev/null || true' --query 'Command.CommandId' --output text 2>/dev/null || true)
            sleep 6
            pods=$(aws ssm get-command-invocation --command-id "$CID" --instance-id "$iid" --query 'StandardOutputContent' --output text 2>/dev/null || true)
            echo "Pods:\n$pods" | sed 's/\t/ /g'
            ready_graf=$(echo "$pods" | grep -i grafana | grep -cE 'Running|Completed' || true)
            ready_prom=$(echo "$pods" | grep -i prometheus | grep -cE 'Running|Completed' || true)
            if [ $ready_graf -ge 1 ] && [ $ready_prom -ge 1 ]; then echo "Monitoring pods appear running"; break; fi
            sleep 10
          done
          echo "Finished monitoring pod wait"

      - name: Poll k3s readiness (nodes)
        if: ${{ steps.apply_final.outputs.final_apply_exit_code == '0' }}
        id: k3s_ready
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          if [ -z "$iid" ] || [ "$iid" = "UNKNOWN" ] || ! echo "$iid" | grep -q '^i-'; then echo "Skipping k3s poll (invalid instance id)"; exit 0; fi
          deadline=$((SECONDS+300))
          echo "Polling k3s node readiness via SSM (5 min timeout)"
          while [ $SECONDS -lt $deadline ]; do
            CID=$(aws ssm send-command --instance-ids "$iid" --document-name AWS-RunShellScript --parameters commands='k3s kubectl get nodes --no-headers 2>/dev/null || true' --query 'Command.CommandId' --output text 2>/dev/null || true)
            sleep 5
            out=$(aws ssm get-command-invocation --command-id "$CID" --instance-id "$iid" --query 'StandardOutputContent' --output text 2>/dev/null || true)
            echo "Node query: $out"
            if echo "$out" | grep -q 'Ready'; then echo "k3s_ready=true" >> $GITHUB_OUTPUT; break; fi
            sleep 7
          done
          echo "Finished k3s readiness polling"

      - name: Validate ingress & monitoring
        if: ${{ steps.apply_final.outputs.final_apply_exit_code == '0' }}
        id: validate
        run: |
          ip=${{ steps.tf-out.outputs.server_ip }}
          if [ -z "$ip" ] || [ "$ip" = "UNKNOWN" ]; then echo "Missing IP" >&2; exit 1; fi
          echo "Validating ingress http://$ip/"
          ok=false
          for i in $(seq 1 25); do
            code=$(curl -s -o /dev/null -w '%{http_code}' --max-time 5 "http://$ip/" || echo 000)
            echo "Attempt $i code=$code"
            if [ "$code" = "200" ]; then ok=true; break; fi
            sleep 5
          done
          if [ "$ok" != true ]; then
            echo "Ingress unreachable; trying NodePort fallback (30080)" >&2
            for i in $(seq 1 15); do
              np_code=$(curl -s -o /dev/null -w '%{http_code}' --max-time 5 "http://$ip:30080/" || echo 000)
              echo "NodePort attempt $i code=$np_code"
              if [ "$np_code" = "200" ]; then ok=true; echo "nodeport_used=true" >> $GITHUB_OUTPUT; break; fi
              sleep 4
            done
          else
            echo "Ingress reachable"; echo "nodeport_used=false" >> $GITHUB_OUTPUT
          fi
          if [ "$ok" != true ]; then echo "validation_result=failure" >> $GITHUB_OUTPUT; echo "Application endpoints unreachable" >&2; exit 1; fi
          echo "Application reachable (ok=$ok)"
          if [ '${{ github.event.inputs.enable_monitoring }}' = 'true' ]; then
            echo "Checking monitoring endpoints (Grafana 30030 login path, Prometheus 30900 /-/ready)"
            graf=false; prom=false
            for i in $(seq 1 30); do
              g=$(curl -s -o /dev/null -w '%{http_code}' --max-time 5 "http://$ip:30030/login" || echo 000)
              p=$(curl -s -o /dev/null -w '%{http_code}' --max-time 5 "http://$ip:30900/-/ready" || echo 000)
              echo "Mon Attempt $i grafana=$g prometheus=$p"
              [[ $g =~ ^(200|302|401)$ ]] && graf=true
              [ "$p" = "200" ] && prom=true
              if [ "$graf" = true ] && [ "$prom" = true ]; then break; fi
              sleep 6
            done
            echo "grafana_ok=$graf" >> $GITHUB_OUTPUT
            echo "prometheus_ok=$prom" >> $GITHUB_OUTPUT
            if [ "$graf" != true ] || [ "$prom" != true ]; then echo "validation_result=failure" >> $GITHUB_OUTPUT; echo "Monitoring endpoints unreachable" >&2; exit 1; fi
            echo "Monitoring reachable"
          fi
          echo "validation_result=success" >> $GITHUB_OUTPUT

      - name: Fetch monitoring exposure log
        if: ${{ always() && github.event.inputs.enable_monitoring == 'true' && steps.apply_final.outputs.final_apply_exit_code == '0' }}
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          if [ -z "$iid" ] || [ "$iid" = "UNKNOWN" ]; then echo "Skip monitoring log fetch (invalid instance id)"; exit 0; fi
          CID=$(aws ssm send-command --instance-ids "$iid" --document-name AWS-RunShellScript --parameters commands='if [ -f /var/log/k3s_monitoring_expose.log ]; then tail -n 300 /var/log/k3s_monitoring_expose.log; else echo "(no monitoring expose log)"; fi' --query 'Command.CommandId' --output text 2>/dev/null || true)
          sleep 6
          aws ssm get-command-invocation --command-id "$CID" --instance-id "$iid" --query 'StandardOutputContent' --output text > monitoring-expose.log 2>/dev/null || echo "(no monitoring expose log)" > monitoring-expose.log

      - name: SSM diagnostics on validation failure
        if: ${{ failure() && steps.apply_final.outputs.final_apply_exit_code == '0' }}
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          if [ -z "$iid" ] || [ "$iid" = "UNKNOWN" ] || ! echo "$iid" | grep -q '^i-'; then echo "Skip diagnostics (invalid instance id)"; exit 0; fi
          echo "Collecting failure diagnostics via SSM"
          CMD_ID=$(aws ssm send-command --instance-ids "$iid" --document-name AWS-RunShellScript --parameters commands='echo "===== kubectl get nodes ====="; k3s kubectl get nodes -o wide || true; echo "===== kubectl get pods -A (top 40) ====="; k3s kubectl get pods -A -o wide | head -n 40 || true; echo "===== kubectl get svc -A ====="; k3s kubectl get svc -A || true; echo "===== kubectl get ingress -A ====="; k3s kubectl get ingress -A || true; echo "===== describe ingress hello-world ====="; k3s kubectl describe ingress hello-world -n hello-world || true; echo "===== tail cloud-init-output.log (120) ====="; tail -n 120 /var/log/cloud-init-output.log || true;' --query 'Command.CommandId' --output text 2>/dev/null || true)
          sleep 6
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$iid" --query 'StandardOutputContent' --output text > validation-ssm-curl.txt 2>/dev/null || true
          echo "Saved validation-ssm-curl.txt"

      - name: Fetch EC2 console output
        if: ${{ always() && steps.apply_final.outputs.final_apply_exit_code == '0' }}
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          if [ -z "$iid" ] || [ "$iid" = "UNKNOWN" ]; then echo "Skip console output (invalid instance id)"; exit 0; fi
          aws ec2 get-console-output --instance-id "$iid" --latest --output text > console-output.txt 2>/dev/null || echo "(No console output)" > console-output.txt

      - name: Minimal SSM diagnostics (always)
        if: ${{ always() && steps.apply_final.outputs.final_apply_exit_code == '0' }}
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          if [ -z "$iid" ] || [ "$iid" = "UNKNOWN" ] || ! echo "$iid" | grep -q '^i-'; then echo "Skip SSM diagnostics (invalid instance id)"; exit 0; fi
          JSON_B64=$(printf '%s' '{"commands":["echo ==== kubectl get nodes ====; k3s kubectl get nodes -o wide || true","echo ==== kubectl get pods -A (top 30) ====; k3s kubectl get pods -A -o wide | head -n 30 || true","echo ==== kubectl get svc -A ====; k3s kubectl get svc -A || true","echo ==== kubectl get ingress -A ====; k3s kubectl get ingress -A || true"]}' | base64 -w0 2>/dev/null || base64)
          echo "$JSON_B64" | base64 -d > params.json 2>/dev/null || echo "$JSON_B64" | base64 --decode > params.json
          CID=$(aws ssm send-command --instance-ids "$iid" --document-name AWS-RunShellScript --comment "Minimal diagnostics" --parameters file://params.json --query 'Command.CommandId' --output text 2>/dev/null || true)
          sleep 6
          aws ssm get-command-invocation --command-id "$CID" --instance-id "$iid" --query 'StandardOutputContent' --output text > ssm-diagnostics.txt 2>/dev/null || echo "(No SSM diagnostics)" > ssm-diagnostics.txt

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-test-diagnostics
          path: |
            infra/terraform.tfstate
            terraform-apply.log
            console-output.txt
            ssm-diagnostics.txt
            validation-ssm-curl.txt
            monitoring-expose.log
          if-no-files-found: warn

      - name: Terraform Destroy (cleanup)
        if: ${{ always() && github.event.inputs.keep_resources != 'true' && (github.event.inputs.keep_on_failure != 'true' || (steps.apply_final.outputs.final_apply_exit_code == '0' && steps.validate.outputs.validation_result == 'success')) }}
        working-directory: infra
        run: terraform destroy -auto-approve

      - name: Summary
        if: always()
        run: |
          echo "## Deploy Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "Instance IP: ${{ steps.tf-out.outputs.server_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "Instance ID: ${{ steps.tf-out.outputs.instance_id }}" >> $GITHUB_STEP_SUMMARY
          echo "Initial Apply Exit Code: ${{ steps.apply.outputs.apply_exit_code }}" >> $GITHUB_STEP_SUMMARY
          echo "Retry Apply Exit Code: ${{ steps.apply_retry.outputs.apply_retry_exit_code || 'n/a' }}" >> $GITHUB_STEP_SUMMARY
          echo "Final Apply Exit Code: ${{ steps.apply_final.outputs.final_apply_exit_code || steps.apply.outputs.apply_exit_code }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.apply_final.outputs.final_apply_exit_code }}" = "0" ]; then
            echo "Validation Result: ${{ steps.validate.outputs.validation_result || 'skipped' }}" >> $GITHUB_STEP_SUMMARY
            echo "NodePort Used: ${{ steps.validate.outputs.nodeport_used || 'false' }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "Validation Result: skipped (apply failed)" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ github.event.inputs.enable_monitoring }}" = "true" ]; then
            echo "Grafana OK: ${{ steps.validate.outputs.grafana_ok || 'false' }}" >> $GITHUB_STEP_SUMMARY
            echo "Prometheus OK: ${{ steps.validate.outputs.prometheus_ok || 'false' }}" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "${{ steps.apply_final.outputs.final_apply_exit_code || steps.apply.outputs.apply_exit_code }}" != "0" ]; then exit 1; fi
          if [ "${{ steps.validate.outputs.validation_result }}" != "success" ]; then exit 1; fi
