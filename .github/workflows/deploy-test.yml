name: Ephemeral Deploy Test

on:
  workflow_dispatch:
    inputs:
      instance_type:
        description: EC2 instance type
        required: false
        default: t3.micro
      keep_resources:
        description: 'Keep resources after test (true/false)'
        required: false
        default: 'false'
      k3s_node_count:
        description: 'Number of agent nodes'
        required: false
        default: '0'
      environment:
        description: 'Environment tag (for resource naming)'
        required: false
        default: 'gha-test'
      readiness_attempts:
        description: 'Number of validation attempts (10s interval)'
        required: false
        default: '72'
      enable_monitoring:
        description: 'Install monitoring stack (true/false)'
        required: false
        default: 'false'
      install_docker:
        description: 'Install Docker engine (true/false)'
        required: false
        default: 'false'

concurrency:
  group: deploy-test
  cancel-in-progress: false

env:
  TF_IN_AUTOMATION: 1
  AWS_REGION: us-east-1
  TERRAFORM_CLI_ARGS: -no-color
  # HAS_SSH_KEY will be set dynamically by a step

jobs:
  deploy-validate-destroy:
    name: Provision → Validate → (Destroy)
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect secrets
        id: detect
        run: |
          if [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then echo "HAS_SSH_KEY=true" >> $GITHUB_ENV; fi
          if [ -n "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && [ -n "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then echo "HAS_AWS_CREDS=true" >> $GITHUB_ENV; else echo "HAS_AWS_CREDS=false" >> $GITHUB_ENV; fi

      - name: Fail fast if AWS credentials missing
        if: env.HAS_AWS_CREDS != 'true'
        run: |
          echo "ERROR: AWS credentials not provided. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY repository or environment secrets." >&2
          exit 1

      - name: Configure AWS credentials
        if: env.HAS_AWS_CREDS == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify AWS identity
        if: env.HAS_AWS_CREDS == 'true'
        run: aws sts get-caller-identity

      - name: Prepare SSH key (optional validation via SSH)
        if: env.HAS_SSH_KEY == 'true'
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_k3s_aws
          chmod 600 ~/.ssh/id_k3s_aws
          printf "Host *\n  StrictHostKeyChecking no\n" > ~/.ssh/config

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ~1.0

      - name: Terraform Init
        working-directory: infra
        run: terraform init -input=false

      - name: Terraform Plan
        id: plan
        working-directory: infra
        run: |
          terraform plan \
            -var="ssh_key_name=${{ secrets.AWS_SSH_KEY_NAME }}" \
            -var="instance_type=${{ github.event.inputs.instance_type }}" \
            -var="k3s_node_count=${{ github.event.inputs.k3s_node_count }}" \
            -var="environment=${{ github.event.inputs.environment || 'gha-test' }}" \
            -var="enable_monitoring=${{ github.event.inputs.enable_monitoring == 'true' }}" \
            -var="install_docker=${{ github.event.inputs.install_docker == 'true' }}" \
            -out=tfplan

      - name: Terraform Apply
        working-directory: infra
        run: terraform apply -auto-approve tfplan

      - name: Capture Outputs
        id: tf-out
        working-directory: infra
        run: |
          echo "server_ip=$(terraform output -raw server_public_ip)" >> $GITHUB_OUTPUT || echo "server_ip=UNKNOWN" >> $GITHUB_OUTPUT
          echo "instance_id=$(terraform output -raw server_instance_id)" >> $GITHUB_OUTPUT || echo "instance_id=UNKNOWN" >> $GITHUB_OUTPUT

      - name: Echo Terraform outputs
        run: |
          echo "Server IP: ${{ steps.tf-out.outputs.server_ip }}"

      - name: Initial warm-up wait
        run: |
          ip=${{ steps.tf-out.outputs.server_ip }}
          echo "Allowing initial 60s warm-up before active validation (IP: $ip)"
          sleep 60

      - name: Active endpoint validation (Ingress + NodePort)
        id: active-validate
        continue-on-error: true
        run: |
          ip=${{ steps.tf-out.outputs.server_ip }}
          attempts=${{ github.event.inputs.readiness_attempts }}
          echo "Running scripts/validate_endpoints.sh $ip $attempts 10"
          chmod +x scripts/validate_endpoints.sh || true
          if ! scripts/validate_endpoints.sh "$ip" "$attempts" 10; then
            echo "Endpoint validation did not succeed within given attempts" >&2
            echo "validation_result=failure" >> $GITHUB_OUTPUT
          else
            echo "validation_result=success" >> $GITHUB_OUTPUT
          fi

      - name: Run endpoint validation script
        if: cancelled() == false
        run: |
          echo "(Secondary validation skipped: replaced by Active endpoint validation step)"
          true

      - name: Optional SSH diagnostics
        if: env.HAS_SSH_KEY == 'true'
        continue-on-error: true
        run: |
          ip=${{ steps.tf-out.outputs.server_ip }}
          echo "Collecting remote diagnostics from $ip"
          for cmd in \
            "sudo systemctl status k3s --no-pager" \
            "sudo journalctl -u k3s -n 400 --no-pager" \
            "sudo tail -n 200 /var/log/cloud-init-output.log" \
            "sudo k3s kubectl get nodes -o wide" \
            "sudo k3s kubectl get pods -A -o wide" \
            "sudo k3s kubectl get svc -A" \
            "sudo k3s kubectl get ingress -A" \
            "sudo k3s kubectl describe ingress -A || true" \
            "sudo k3s kubectl describe pods -n hello-world || true"; do
              echo "===== $cmd =====";
              ssh -i ~/.ssh/id_k3s_aws ubuntu@"$ip" "$cmd" || true;
            done > diagnostics.txt

      - name: Fetch EC2 console output
        if: always()
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          echo "Instance ID: $iid"
          if [ "$iid" = "UNKNOWN" ]; then echo "Instance ID unknown, skipping console output"; exit 0; fi
          aws ec2 get-console-output --instance-id "$iid" --latest --output text > console-output.txt 2>/dev/null || echo "(No console output yet)" > console-output.txt
          ls -l console-output.txt

      - name: SSM diagnostics (no SSH key)
        if: always() && env.HAS_AWS_CREDS == 'true' && env.HAS_SSH_KEY != 'true'
        run: |
          iid=${{ steps.tf-out.outputs.instance_id }}
          if [ "$iid" = "UNKNOWN" ]; then echo "Instance ID unknown, skipping SSM diagnostics"; exit 0; fi
          echo "Sending SSM diagnostics command to $iid"
          CMD_ID=$(aws ssm send-command \
            --instance-ids "$iid" \
            --document-name AWS-RunShellScript \
            --comment "Collect k3s diagnostics" \
            --parameters commands='#!/bin/bash
            set -x
            echo "===== tail cloud-init-output.log (400 lines) ====="; tail -n 400 /var/log/cloud-init-output.log 2>&1 || true;
            if [ -f /var/log/k3s_diagnostics_hello_world.txt ]; then echo "===== k3s_diagnostics_hello_world.txt (200 lines) ====="; tail -n 200 /var/log/k3s_diagnostics_hello_world.txt; fi;
            echo "===== kubectl get nodes -o wide ====="; sudo k3s kubectl get nodes -o wide 2>&1 || true;
            echo "===== kubectl get pods -A -o wide ====="; sudo k3s kubectl get pods -A -o wide 2>&1 || true;
            echo "===== kubectl get svc -A ====="; sudo k3s kubectl get svc -A 2>&1 || true;
            echo "===== kubectl get ingress -A ====="; sudo k3s kubectl get ingress -A 2>&1 || true;
            echo "===== kubectl describe ingress hello-world -n hello-world ====="; sudo k3s kubectl describe ingress hello-world -n hello-world 2>&1 || true;
            ' \
            --query 'Command.CommandId' --output text)
          echo "Command ID: $CMD_ID"
          # Poll status
          for i in $(seq 1 30); do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text || echo "Unknown")
            echo "SSM command status: $STATUS"
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ]; then break; fi
            sleep 6
          done
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$iid" --query 'StandardOutputContent' --output text > ssm-diagnostics.txt 2>/dev/null || echo "(No SSM output)" > ssm-diagnostics.txt
          echo "SSM diagnostics captured (size $(wc -c < ssm-diagnostics.txt) bytes)"

      - name: Upload diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deploy-test-diagnostics
          path: |
            infra/terraform.tfstate
            diagnostics.txt
            console-output.txt
            ssm-diagnostics.txt
          if-no-files-found: warn

      - name: Terraform Destroy (ephemeral cleanup)
        if: always() && github.event.inputs.keep_resources != 'true'
        working-directory: infra
        run: terraform destroy -auto-approve

      - name: Summary
        if: always()
        run: |
          echo "## Deploy Test Summary" >> $GITHUB_STEP_SUMMARY
          echo "Instance IP: ${{ steps.tf-out.outputs.server_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "Kept Resources: ${{ github.event.inputs.keep_resources }}" >> $GITHUB_STEP_SUMMARY
          echo "Instance Type: ${{ github.event.inputs.instance_type }}" >> $GITHUB_STEP_SUMMARY
          echo "Environment: ${{ github.event.inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "Instance ID: ${{ steps.tf-out.outputs.instance_id }}" >> $GITHUB_STEP_SUMMARY
          echo "Validation Result: ${{ steps.active-validate.outputs.validation_result || 'unknown' }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.active-validate.outputs.validation_result }}" != "success" ]; then
            echo "Validation failed (see diagnostics artifact)." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
